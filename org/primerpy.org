#+TITLE: PrimerPy: A Primer on Data Science Coding

#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./
#+HUGO_WEIGHT: auto
#+HUGO_AUTO_SET_LASTMOD: t

* Data Science in Python                     :@Python:

** Basics                                    :python:basic:
:PROPERTIES:
:EXPORT_FILE_NAME: python-basics
:EXPORT_DATE: 2017-11-07
:EXPORT_HUGO_MENU: :menu "python"
:END:

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
students = []
def add_student(name):
    print(name)
    students.append(name)
    print("{a} is added to the students database".format(a = name))

add_student("Isaac")
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
def first_element(my_list):
    return my_list[:2]

# invoke the function
movies = [['Avatar', 'James Cameron', 'Color', '178', 'CCH Pounder', 'English', 'USA', '2009'], 
          ["Pirates of the Caribbean: At World's End", 'Gore Verbinski', 'Color', '169', 'Johnny Depp', 'English', 'USA', '2007'], 
          ['Spectre', 'Sam Mendes', 'Color', '148', 'Christoph Waltz', 'English', 'UK', '2015'], 
          ['The Dark Knight Rises', 'Christopher Nolan', 'Color', '164', 'Tom Hardy', 'English', 'USA', '2012']]
first_element(movies)
#+END_SRC

#+RESULTS:
:RESULTS:
| Avatar                                   | James Cameron  | Color | 178 | CCH Pounder | English | USA | 2009 |
| Pirates of the Caribbean: At World's End | Gore Verbinski | Color | 169 | Johnny Depp | English | USA | 2007 |
:END:

** Function                                  :python:function:
:PROPERTIES:
:EXPORT_FILE_NAME: python-function
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU: :menu "python"
:END:
*** User-defined Functions
*** All About Arguments
*** Lambda
*** Error Handling 

** Visualization                             :python:visualization:matplotlib:
*** Multiple Plots                           :python:visualization:matplotlib:mutiple:
**** Prep & Review                           :python:visualization:matplotlib:multiple:prep:
:PROPERTIES: 
:EXPORT_FILE_NAME: multiple-plots-prep
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
     First, let's review how to create single chart. We'll use unemployment data from US Bureau of Labor Statistics. Here are the steps
     1. Use pandas to load a csv file to a DataFrame
     2. Use Pandas.to_datetime to convert the DATE column into a Series of datetime values
     3. Create a line chart that visualize the unemployment from 1948:
        1) x-values should be the first 12 values in the DATE column
        2) y-values should be the first 12 values in the VALUE column
     4. Formatting the chart
        1) use pyplot.xticks() to rotate x-axis tick labels by 90 degrees
        2) Use pyplot.xlabel() to set the x-axis label to "Month"
        3) Use pyplot.ylabel() to set the y-axis label to "Unemployment Rate"
        4) Use pyplot.title() to set the plot title to "Monthly Unemployment Trends, 1948"
     5. Display the plot


#+BEGIN_SRC ipython :session :file ../static/pyplot/unrate-single.png  :exports both :results raw drawer
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

data_path = "../data/unrate.csv"
unrate = pd.read_csv(data_path)
unrate["DATE"] = pd.to_datetime(unrate["DATE"])

plt.plot(unrate["DATE"].iloc[:12], unrate["VALUE"].iloc[:12])

plt.xticks(rotation=90)
plt.xlabel("Month")
plt.ylabel("Unemployment Rate")
plt.title("Monthly Unemployment Trends, 1948")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/unrate-single.png]]
:END:

**** Matplotlib Classes                      :python:visualization:matplotlib:multiple:class:
:PROPERTIES:
:EXPORT_FILE_NAME: matplotlib-classes
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:

When we were working with a single plot, pyplot was storing and updating the state of that single plot. We could tweak the plot just using the functions in the pyplot module. When we want to work with multiple plots, however, we need to be more explicit about which plot we're making changes to. This means we need to understand the matplotlib classes that pyplot uses internally to maintain state so we can interact with them directly. Let's first start by understanding what pyplot was automatically storing under the hood when we create a single plot:

- a container for all plots was created (returned as a Figure object)
- a container for the plot was positioned on a grid (the plot returned as an Axes object)
- visual symbols were added to the plot (using the Axes methods)

A figure acts as a container for all of our plots and has methods for customizing the appearance and behavior for the plots within that container. Some examples include changing the overall width and height of the plotting area and the spacing between plots.

We can manually create a figure by calling pyplot.figure():

#+begin_src python
fig = plt.figure()
#+end_src

Instead of only calling the pyplot function, we assigned its return value to a variable (fig). After a figure is created, an axes for a single plot containing no data is created within the context of the figure. When rendered without data, the plot will resemble the empty plot. The Axes object acts as its own container for the various components of the plot, such as:

- values on the x-axis and y-axis
- ticks on the x-axis and y-axis
- all visual symbols, such as:
  + markers
  + lines
  + gridlines

While plots are represented using instances of the Axes class, they're also often referred to as subplots in matplotlib. To add a new subplot to an existing figure, use Figure.add_subplot. This will return a new Axes object, which needs to be assigned to a variable:

#+begin_src python
axes_obj = fig.add_subplot(nrows, ncols, plot_number)
#+end_src

If we want the figure to contain 2 plots, one above the other, we need to write:

#+begin_src python
ax1 = fig.add_subplot(2,1,1)
ax2 = fig.add_subplot(2,1,2)
#+end_src

This will create a grid, 2 rows by 1 column, of plots. Once we're done adding subplots to the figure, we display everything using plt.show(), unless using %matplotlib inline with Jupyter Notebook

#+begin_src python
import matplotlib.pyplot as plt
fig = plt.figure()
ax1 = fig.add_subplot(2,1,1)
ax2 = fig.add_subplot(2,1,2)
plt.show()
#+end_src

**** Create Subplot                          :python:visualization:matplotlib:multiple:subplot:
:PROPERTIES:
:EXPORT_FILE_NAME: create-subplot
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:

     Create subplots by following the steps below
     1. Use plt.figure() to create a figure and assign to fig
     2. Use Figure.add_subplot() to create two subplots: 2 rows 1 col
     3. Assign the top axes object to ax1
     4. Assign the bottom axes object to ax2
     5. Display the chart
     6. Use plt.tight_layout() to automatically adjusts subplot params so that the subplot(s) fits in to the figure area.
#+BEGIN_SRC ipython :session :file ../static/pyplot/subplot.png :exports both :results raw drawer
import matplotlib.pyplot as plt
fig = plt.figure()
ax1 = fig.add_subplot(2,1,1)
ax2 = fig.add_subplot(2,1,2)
plt.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/subplot.png]]
:END:

**** Adding Data                             :python:visualization:matplotlib:multiple:subplot:
:PROPERTIES:
:EXPORT_FILE_NAME: adding-data
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
     To generate a line chart within an Axes object, we need to call Axes.plot() and passe the data you want plotted:
#+begin_src python
x_values = [0.0, 0.5, 1.0]
y_values = [10, 20, 40]
ax1.plot(x_values, y_values)
#+end_src

Like pyplot.plot(), the Axes.plot() will accept any iterable object for these parameters, including NumPy arrays and pandas Series objects. It will also use generate a line chart by default from the values passed in. Each time we want to generate a line chart, we need to call Axes.plot() and pass in the data we want to use in that plot.

Create 2 line subplots in a 2 row by 1 column layout:
1. In the top subplot, plot the data from 1948.
   1) For the x-axis, use the first 12 values in the DATE column.
   2) For the y-axis, use the first 12 values in the VALUE column.
2. In the bottom subplot, plot the data from 1949.
   1) For the x-axis, use the values from index 12 to 24 in the DATE column.
   2) For the y-axis, use the values from index 12 to 24 in the VALUE column.
3. Use figsize=(width, height) in plt.figure() to resize the chart
4. use plt.tight_layout() **before** plt.show() to auto fit subplots 

#+BEGIN_SRC ipython :session :file ../static/pyplot/adding-data.png :exports both :results raw drawer
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(9,5))
ax1 = fig.add_subplot(2,1,1)
ax2 = fig.add_subplot(2,1,2)

ax1.plot(unrate["DATE"].iloc[:12], unrate["VALUE"].iloc[:12])
ax2.plot(unrate["DATE"].iloc[12:24], unrate["VALUE"].iloc[12:24])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/adding-data.png]]
:END:

**** Adding More Data                        :python:visualization:matplotlib:multiple:subplot:
:PROPERTIES:
:EXPORT_FILE_NAME: adding-more-data
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
     Instead of having to rotate the x-axis tick labels, we were able to horizontally extend the entire plotting area to make the labels more readable. Because the goal is to be able to look for any visual similarities between the lines in the plots, we want the space between the 2 plots to be as small as possible. If we had rotated the labels by 90 degrees instead, like most people would do, we'd need to increase the spacing between the plots to keep them from overlapping. Expanding the plotting area horizontally improved the readability of the x-axis tick labels and minimized the amount of space between the 2 line charts.
     
     we generated these 2 line charts because we were interested in looking for any seasonality in the monthly unemployment trends. If you spend some time visually analyzing both line charts, you'll discover that there's no changes in unemployment trends that are occurring in the same month in both years.
     
     Let's visualize data from a few more years to see if we find any evidence for seasonality between those years.
     1. Set the width of the plotting area to 12 inches and the height to 12 inches.
     2. Generate a grid with 5 rows and 1 column and plot data from the individual years. Start with 1948 in the top subplot and end with 1952 in the bottom subplot.
     3. Use plt.show() to display the plots.
#+BEGIN_SRC ipython :session :file ../static/pyplot/more-data.png  :exports both :results raw drawer
fig = plt.figure(figsize=(12,12))

for i in range(5):
    ax = fig.add_subplot(5,1,i+1)
    start_i = i * 12
    end_i = (i+1) * 12
    subset = unrate[start_i:end_i]
    ax.plot(subset["DATE"], subset["VALUE"])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/more-data.png]]
:END:

**** Overlaying Line Charts                  :python:visualization:matplotlib:multiple:subplot:overlaying:
:PROPERTIES:
:EXPORT_FILE_NAME: overlaying-line-charts
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
     By adding more line charts, we can look across more years for seasonal trends. This comes at a cost, unfortunately. We now have to visually scan over more space, which is a limitation.

     We can handle the visual overhead each additional plot adds by overlaying the line charts in a single subplot. If we remove the year from the x-axis and just keep the month values, we can use the same x-axis values to plot all of the lines. First, we'll explore how to extract just the month values from the DATE column, then we'll dive into generating multiple plots on the same coordinate grid.

     To extract the month values from the DATE column and assign them to a new column, we can use the pandas.Series.dt accessor:
#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
unrate['MONTH'] = unrate['DATE'].dt.month
unrate[["DATE","MONTH"]].head(15)
#+END_SRC

#+RESULTS:
:RESULTS:
         DATE  MONTH
0  1948-01-01      1
1  1948-02-01      2
2  1948-03-01      3
3  1948-04-01      4
4  1948-05-01      5
5  1948-06-01      6
6  1948-07-01      7
7  1948-08-01      8
8  1948-09-01      9
9  1948-10-01     10
10 1948-11-01     11
11 1948-12-01     12
12 1949-01-01      1
13 1949-02-01      2
14 1949-03-01      3
:END:

Calling pandas.Series.dt.month returns a Series containing the integer values for each month (e.g. 1 for January, 2 for February, etc.). Under the hood, pandas applies the datetime.date function over each datetime value in the DATE column, which returns the integer month value. Let's now move onto generating multiple line charts in the same subplot.

We called pyplot.plot() to generate a single line chart. Under the hood, matplotlib created a figure and a single subplot for this line chart. If we call pyplot.plot() multiple times, matplotlib will generate the line charts on the single subplot.

#+BEGIN_SRC ipython :session :file ../static/pyplot/overlay-temp.png :exports both :results raw drawer
plt.plot(unrate[0:12]['MONTH'], unrate[0:12]['VALUE'])
plt.plot(unrate[12:24]['MONTH'], unrate[12:24]['VALUE'])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/overlay-temp.png]]
:END:

If we want to set the dimensions for the plotting area, we can create the figure ourselves first then plot the data. This is because matplotlib first checks if a figure already exists before plotting data. It will only create one if we didn't create a figure.

By default, matplotlib will select a different color for each line. To specify the color ourselves, use the c parameter when calling plot():
#+BEGIN_SRC ipython :session :file ../static/pyplot/overlay-temp1.png  :exports both :results raw drawer
fig = plt.figure(figsize=(12,5))
plt.plot(unrate[0:12]['MONTH'], unrate[0:12]['VALUE'], c="steelblue")
plt.plot(unrate[12:24]['MONTH'], unrate[12:24]['VALUE'], c="#D0104C")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/overlay-temp1.png]]
:END:

Now plot the overlaying line charts for 5 years:
- Set the plotting area to a width of 10 inches and a height of 6 inches.
- Generate the following plots in the base subplot:
  + 1948: set the line color to "red"
  + 1949: set the line color to "blue"
  + 1950: set the line color to "green"
  + 1951: set the line color to "orange"
  + 1952: set the line color to "black"

#+BEGIN_SRC ipython :session :file ../static/pyplot/overlay-plot.png  :exports both :results raw drawer
fig = plt.figure(figsize=(10,6))
colors = ["red", "blue", "green", "orange", "black"]

for i in range(5):
    start_i = i * 12
    end_i = (i+1) * 12
    subset = unrate[start_i:end_i]
    plt.plot(subset["MONTH"], subset["VALUE"], c = colors[i])

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/overlay-plot.png]]
:END:

**** Adding a Legend and Title               :python:visualization:matplotlib:multiple:subplot:legend:title:
:PROPERTIES:
:EXPORT_FILE_NAME: adding-legend-title
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
To help remind us which year each line corresponds to, we can add a legend that links each color to the year the line is representing. Here's what a legend for the lines in the last screen could look like:

When we generate each line chart, we need to specify the text label we want each color linked to. The pyplot.plot() function contains a label parameter, which we use to set the year value:
#+begin_src python
plt.plot(unrate[0:12]['MONTH'], unrate[0:12]['VALUE'], c='red', label='1948')
plt.plot(unrate[12:24]['MONTH'], unrate[12:24]['VALUE'], c='blue', label='1949')
#+end_src

We can create the legend using pyplot.legend and specify its location using the loc parameter:
#+begin_src python
plt.legend(loc='upper left')
#+end_src

If we're instead working with multiple subplots, we can create a legend for each subplot by mirroring the steps for each subplot. When we use plt.plot() and plt.legend(), the Axes.plot() and Axes.legend() methods are called under the hood and parameters passed to the calls. When we need to create a legend for each subplot, we can use Axes.legend() instead.

Finally, let's enhance the visualization by adding a title and labels for both axes. To set the title, we use pyplot.title() and pass in a string value:
#+begin_src python
plt.title("Monthly Unemployment Trends, 1948-1952")
#+end_src

To set the x-axis and y-axis labels, we use pyplot.xlabel() and pyplot.ylabel(). Both of these methods accept string values.

Let's now add a legend for the plot we generated in the last screen.

- Modify the code from the last screen that overlaid 5 plots to include a legend. Use the year value for each line chart as the label.
  + E.g. the plot of 1948 data that uses "red" for the line color should be labeled "1948" in the legend.
- Place the legend in the "upper left" corner of the plot.


#+BEGIN_SRC ipython :session :file ../static/pyplot/adding-legend-title.png :exports both :results raw drawer
fig = plt.figure(figsize=(12,6))
colors = ['red', 'blue', 'green', 'orange', 'black']
year = [1948, 1949, 1950, 1951, 1952]

for i in range(5):
    start_i = i * 12
    end_i = (i+1) * 12
    subset = unrate[start_i:end_i]
    plt.plot(subset["MONTH"], subset["VALUE"], c=colors[i], label = year[i])

plt.tight_layout()
plt.legend(loc="upper left")
plt.title("Monthly Unemployment Trends, 1948-1952")
plt.xlabel("Month (Integer)")
plt.ylabel("Unemployment Rate (Percent %)")
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/adding-legend-title.png]]
:END:

*** Discrete Plots                           :python:visualization:matplotlib:discrete:

Line charts were an appropriate choice for visualizing datasets natural orderings. Each row reflected information about an event that occurred after the previous row. Changing the order of the rows would make the line chart inaccurate. The lines from one marker to the next helped emphasize the logical connection between the data points.

In this section, we'll be working with a dataset that has no particular order. For this type of data, discrete plots such as bar and scatter plots make more sense.

**** Data Preparation                        :python:visualization:matplotlib:discrete:data:
:PROPERTIES:
:EXPORT_FILE_NAME: data-preparation
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
In this section, we will use the fandango data compiled by FiveThirtyEight. Let's prepare the data first:
- Read fandango_scores.csv into a Dataframe named reviews.
- Select the following columns and assign the resulting Dataframe to norm_reviews:
  + FILM
  + RT_user_norm
  + Metacritic_user_nom (note the misspelling of norm)
  + IMDB_norm
  + Fandango_Ratingvalue
  + Fandango_Stars
- Display the first row in norm_reviews

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
%matplotlib inline

path = "../data/fandango_scores.csv"
reviews = pd.read_csv(path)
norm_reviews = reviews[["FILM", "RT_user_norm", "Metacritic_user_nom", "IMDB_norm", "Fandango_Ratingvalue", "Fandango_Stars"]]
norm_reviews.iloc[0]
#+END_SRC

#+RESULTS:
:RESULTS:
| FILM                 | Avengers: Age of Ultron (2015) |
|----------------------+--------------------------------|
| RT_user_norm         |                            4.3 |
| Metacritic_user_nom  |                           3.55 |
| IMDB_norm            |                            3.9 |
| Fandango_Ratingvalue |                            4.5 |
| Fandango_Stars       |                              5 |

:END:

**** Bar Plots                               :python:visualization:matplotlib:discrete:barplot:
:PROPERTIES:
:EXPORT_FILE_NAME: bar-plots
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
A bar plot uses rectangular bars whose length are proportional to the values they represents. An effective bar plot uses a consistent width for each bar. This helps keep the visual focus on the heights of the bars when comparing.

When we generated line charts, we passed in the data to pyplot.plot() and matplotlib took care of the rest. Because the markers and lines in a line chart correspond directly with x-axis and y-axis coordinates, all matplotlib needed was the data we wanted plotted. To create a useful bar plot, however, we need to specify the positions of the bars, the widths of the bars, and the positions of the axis labels. Here's a diagram that shows the various values we need to specify:

#+ATTR_ORG: :width 400
[[file:../static/images/matplotlib_barplot_positioning.png]]

We'll focus on positioning the bars on the x-axis in this step and on positioning the x-axis labels in the next step. We can generate a vertical bar plot using either pyplot.bar() or Axes.bar(). We'll use Axes.bar() so we can extensively customize the bar plot more easily. We can use pyplot.subplots() to first generate a single subplot and return both the Figure and Axes object. 

#+begin_src python
fig, ax = plt.subplots()
#+end_src

The Axes.bar() method has 2 required parameters, left and height. We use the left parameter to specify the x coordinates of the left sides of the bar (marked in blue on the above image). We use the height parameter to specify the height of each bar. Both of these parameters accept a list-like object.

The np.arange() function returns evenly spaced values. We use arange() to generate the positions of the left side of our bars. This function requires a paramater that specifies the number of values we want to generate. We'll also want to add space between our bars for better readability:

#+begin_src python
# Positions of the left sides of the 5 bars. [0.75, 1.75, 2.75, 3.75, 4.75]
from numpy import arange
bar_positions = arange(5) + 0.75
​
# Heights of the bars.  In our case, the average rating for the first movie in the dataset.
num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
bar_heights = norm_reviews[num_cols].iloc[0].values
​
ax.bar(bar_positions, bar_heights)
#+end_src

We can also use the width parameter to specify the width of each bar. This is an optional parameter and the width of each bar is set to 0.8 by default. The following code sets the width parameter to 1.5:

#+begin_src python
ax.bar(bar_positions, bar_heights, 1.5)
#+end_src

Now put it all together:

- Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
- Generate a bar plot with:
  + left set to bar_positions
  + height set to bar_heights
  + width set to 0.5

#+BEGIN_SRC ipython :session :file ../static/pyplot/bar-plot1.png :exports both :results raw drawer
import matplotlib.pyplot as plt
import numpy as np
%matplotlib inline

fig, ax = plt.subplots()
num_col = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
bar_heights = norm_reviews[num_col].iloc[0].values
bar_positions = np.arange(5) + 1
ax.bar(bar_positions, bar_heights, 0.5)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/bar-plot1.png]]
:END:

**** Aligning Axis Ticks and Labels          :python:visualization:matplotlib:discrete:barplot:alignment:
:PROPERTIES:
:EXPORT_FILE_NAME: bar-plot-alignment
:EXPORT_DATE: <2017-11-08 Wed>
:EXPORT_HUGO_MENU:
:EXPORT_HUGO_CUSTOME_FRONT_MATTER:
:END:
  If we have 5 data points, by default, matplotlib sets the x-axis tick labels to the integer values the bars spanned on the x-axis (from 0 to 6). We only need tick labels on the x-axis where the bars are positioned. We can use Axes.set_xticks() to change the positions of the ticks to [1, 2, 3, 4, 5]:

  #+begin_src python
tick_positions = range(1,6)
ax.set_xticks(tick_positions)
  #+end_src

  Then, we can use Axes.set_xticklabels() to specify the tick labels:

  #+begin_src python
num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
ax.set_xticklabels(num_cols)
  #+end_src

  We can also specify the orientation for the labels using the rotation parameter:

  #+begin_src python
ax.set_xticklabels(num_cols, rotation=90)
  #+end_src

  Rotating the labels by 90 degrees keeps them readable. In addition to modifying the x-axis tick positions and labels, let's also set the x-axis label, y-axis label, and the plot title.

  - Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
  - Generate a bar plot with:
    + left set to bar_positions
    + height set to bar_heights
    + width set to 0.5
  - Set the x-axis tick positions to tick_positions.
  - Set the x-axis tick labels to num_cols and rotate by 90 degrees.
  - Set the x-axis label to "Rating Source".
  - Set the y-axis label to "Average Rating".
  - Set the plot title to "Average User Rating For Avengers: Age of Ultron (2015)".

  #+BEGIN_SRC ipython :session :file ../static/pyplot/bar-plot2.png :exports both :results raw drawer
fig, ax = plt.subplots(figsize=(12,4))

num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
bar_heights = norm_reviews[num_cols].iloc[0].values
bar_positions = np.arange(5) + 1

ax.bar(bar_positions, bar_heights, 0.5)

tick_positions = range(1,6)
ax.set_xticks(tick_positions)
ax.set_xticklabels(num_cols, rotation=90)

ax.set_xlabel('Rating Source')
ax.set_ylabel('Average Rating')
ax.set_title('Average User Rating For Avengers: Age of Ultron (2015)')

  #+END_SRC

  #+RESULTS:
  :RESULTS:
  [[file:../static/pyplot/bar-plot2.png]]
  :END:

**** Horizontal Bar Plot                     :python:visualization:matplotlib:discrete:barplot:horizontal:
:PROPERTIES:
:EXPORT_FILE_NAME: horizontal-bar-plot
:EXPORT_DATE: <2017-11-08 Wed>
:END:

We can create a horizontal bar plot in matplotlib in a similar fashion. Instead of using Axes.bar(), we use Axes.barh(). This method has 2 required parameters, bottom and width. We use the bottom parameter to specify the y coordinate for the bottom sides for the bars and the width parameter to specify the lengths of the bars:

#+begin_src python
bar_widths = norm_reviews[num_cols].iloc[0].values
bar_positions = arange(5) + 0.75
ax.barh(bar_positions, bar_widths, 0.5)
#+end_src

To recreate the bar plot from the last step as horizontal bar plot, we essentially need to map the properties we set for the y-axis instead of the x-axis. We use Axes.set_yticks() to set the y-axis tick positions to [1, 2, 3, 4, 5] and Axes.set_yticklabels() to set the tick labels to the column names:

#+begin_src python
tick_positions = range(5) + 1
num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
ax.set_yticks(tick_positions)
ax.set_yticklabels(num_cols)
#+end_src

Now let's recreate the horizontal bar plot

- Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
- Generate a bar plot with:
  + bottom set to bar_positions
  + width set to bar_widths
  + height set to 0.5
- Set the y-axis tick positions to tick_positions.
- Set the y-axis tick labels to num_cols.
- Set the y-axis label to "Rating Source".
- Set the x-axis label to "Average Rating".
- Set the plot title to "Average User Rating For Avengers: Age of Ultron (2015)".

#+BEGIN_SRC ipython :session :file ../static/pyplot/bar-plot3.png :exports both :results raw drawer
import matplotlib.pyplot as plt
from numpy import arange

fig, ax = plt.subplots(figsize=(8,6))

num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']

bar_widths = norm_reviews[num_cols].iloc[0].values
bar_positions = arange(5) + 0.75
tick_positions = range(1,6)

ax.barh(bar_positions, bar_widths, 0.5)

tick_positions = range(1,6)
ax.set_yticks(tick_positions)
ax.set_yticklabels(num_cols)

ax.set_ylabel("Rating Source")
ax.set_xlabel("Average Rating")
ax.set_title("Average User Rating For Avengers: Age of Ultron (2015)")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/bar-plot3.png]]
:END:

**** Scatter Plot
:PROPERTIES:
:EXPORT_FILE_NAME: scatter-plot
:EXPORT_DATE: <2017-11-08 Wed>
:END:
While bar plots help us visualize a few data points to quickly compare them, they aren't good at visualizing many data points. A scatter plot is good at visualizing a number of data points. It helps to determine if two variables are correlated or not. A scatter plot helps to find outliers, gain a more intuitive sense of how spread out the data is, and compare more easily.

To generate a scatter plot, we use Axes.scatter(). The scatter() method has 2 required parameters, x and y, which matches the parameters of the plot() method. The values for these parameters need to be iterable objects of matching lengths (lists, NumPy arrays, or pandas series).

Let's start by creating a scatter plot that visualizes the relationship between the Fandango_Ratingvalue and RT_user_norm columns.

- Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
- Generate a scatter plot with the Fandango_Ratingvalue column on the x-axis and the RT_user_norm column on the y-axis.
- Set the x-axis label to "Fandango" and the y-axis label to "Rotten Tomatoes".

#+BEGIN_SRC ipython :session :file ../static/pyplot/scatter-plot1.png :exports both :results raw drawer
fig, ax = plt.subplots(figsize=(10,5))

ax.scatter(norm_reviews["Fandango_Ratingvalue"], norm_reviews["RT_user_norm"])
ax.set_xlabel("Fandango")
ax.set_ylabel("Rotten Tomatoes")
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/scatter-plot1.png]]
:END:

The scatter plot suggests that there's a weak, positive correlation between the user ratings on Fandango and the user ratings on Rotten Tomatoes.

When using scatter plots to understand how 2 variables are correlated, it's usually not important which one is on the x-axis and which one is on the y-axis. This is because the relationship is still captured either way, even if the plots look a little different. If you want to instead understand how an independent variable affects a dependent variables, you want to put the independent one on the x-axis and the dependent one on the y-axis. Doing so helps emphasize the potential cause and effect relation.

Let's see what happens when we flip the columns:

- For the subplot associated with ax1:
  + Generate a scatter plot with the Fandango_Ratingvalue column on the x-axis and the RT_user_norm column on the y-axis.
  + Set the x-axis label to "Fandango" and the y-axis label to "Rotten Tomatoes".
- For the subplot associated with ax2:
  + Generate a scatter plot with the RT_user_norm column on the x-axis and the Fandango_Ratingvalue column on the y-axis.
  + Set the x-axis label to "Rotten Tomatoes" and the y-axis label to "Fandango".

#+BEGIN_SRC ipython :session :file ../static/pyplot/scatter-plot2.png :exports both :results raw drawer
fig, ax = plt.subplots(figsize=(16,8))
ax1 = fig.add_subplot(2,1,1)
ax2 = fig.add_subplot(2,1,2)

ax1.scatter(norm_reviews["Fandango_Ratingvalue"], norm_reviews["RT_user_norm"])
ax1.set_xlabel("Fandango")
ax1.set_ylabel("Rotten Tomatoes")

ax2.scatter(norm_reviews["RT_user_norm"], norm_reviews["Fandango_Ratingvalue"])
ax2.set_xlabel("Rotten Tomatoes")
ax2.set_ylabel("Fandango")

plt.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/scatter-plot2.png]]
:END:

When generating multiple scatter plots for the purpose of comparison, it's important that all plots share the same ranges in the x-axis and y-axis. We can use ~Axes.set_xlim()~ and ~Axes.set_ylim()~ to set the data limits for both axes:

By default, matplotlib uses the minimal ranges for the data limits necessary to display all of the data we specify. By manually setting the data limits ranges to specific ranges for all plots, we're ensuring that we can accurately compare. 

#+BEGIN_SRC ipython :session :file ../static/pyplot/scatter-plot3.png :exports both :results raw drawer
fig = plt.figure(figsize=(10,10))
ax1 = fig.add_subplot(3,1,1)
ax2 = fig.add_subplot(3,1,2)
ax3 = fig.add_subplot(3,1,3)

ax1.scatter(norm_reviews["Fandango_Ratingvalue"], norm_reviews["RT_user_norm"])
ax1.set_xlabel("Fandango")
ax1.set_ylabel("Rotten Tomatoes")
ax1.set_xlim(0,5)
ax1.set_ylim(0,5)

ax2.scatter(norm_reviews["Fandango_Ratingvalue"], norm_reviews["Metacritic_user_nom"])
ax2.set_xlabel("Fandango")
ax2.set_ylabel("Metacritic")
ax2.set_xlim(0,5)
ax2.set_ylim(0,5)

ax3.scatter(norm_reviews["Fandango_Ratingvalue"], norm_reviews["IMDB_norm"])
ax3.set_xlabel("Fandango")
ax3.set_ylabel("IMDB")
ax3.set_xlim(0,5)
ax3.set_ylim(0,5)

plt.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/scatter-plot3.png]]
:END:

**** Distribution
:PROPERTIES:
:EXPORT_FILE_NAME: distribution
:EXPORT_DATE: <2017-11-08 Wed>
:END:

Let's first compare the frequency distributions of user ratings from Fandango with those from IMDB using tables. A column's frequency distribution consists of the unique values in that column along with the count for each of those values (or their frequency). We can use ~Series.value_counts()~ to return the frequency distribution as Series object:

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
import pandas as pd
import matplotlib.pyplot as plt
reviews = pd.read_csv('../data/fandango_scores.csv')
cols = ['FILM', 'RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue']
norm_reviews = reviews[cols]
freq_counts = norm_reviews["Fandango_Ratingvalue"].value_counts()
freq_counts
#+END_SRC

#+RESULTS:
:RESULTS:
4.1    16
4.2    12
3.9    12
4.3    11
3.7     9
3.5     9
4.5     9
3.4     9
3.6     8
4.4     7
4.0     7
3.2     5
2.9     5
3.8     5
3.3     4
4.6     4
3.0     4
4.8     3
3.1     3
2.8     2
2.7     2
Name: Fandango_Ratingvalue, dtype: int64
:END:

The resulting Series object was sorted by frequency in descending order. While this ordering is helpful when we're looking to quickly find the most common values in a given column, it's not helpful when trying to understand the range that the values in the column span. We can use ~Series.sort_index()~ to sort the frequency distribution in ascending order by the values in the column (which make up the index for the Series object):

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
fandango_distribution = norm_reviews["Fandango_Ratingvalue"].value_counts().sort_index()
fandango_distribution
#+END_SRC

#+RESULTS:
:RESULTS:
2.7     2
2.8     2
2.9     5
3.0     4
3.1     3
3.2     5
3.3     4
3.4     9
3.5     9
3.6     8
3.7     9
3.8     5
3.9    12
4.0     7
4.1    16
4.2    12
4.3    11
4.4     7
4.5     9
4.6     4
4.8     3
Name: Fandango_Ratingvalue, dtype: int64
:END:

#+BEGIN_SRC ipython :session :file  :exports both :results raw drawer
imdb_distribution = norm_reviews["IMDB_norm"].value_counts().sort_index()
imdb_distribution
#+END_SRC

#+RESULTS:
:RESULTS:
2.00     1
2.10     1
2.15     1
2.20     1
2.30     2
2.45     2
2.50     1
2.55     1
2.60     2
2.70     4
2.75     5
2.80     2
2.85     1
2.90     1
2.95     3
3.00     2
3.05     4
3.10     1
3.15     9
3.20     6
3.25     4
3.30     9
3.35     7
3.40     1
3.45     7
3.50     4
3.55     7
3.60    10
3.65     5
3.70     8
3.75     6
3.80     3
3.85     4
3.90     9
3.95     2
4.00     1
4.05     1
4.10     4
4.15     1
4.20     2
4.30     1
Name: IMDB_norm, dtype: int64
:END:

**** Histogram
:PROPERTIES:
:EXPORT_FILE_NAME: histogram
:EXPORT_DATE: <2017-11-08 Wed>
:END:
Because there are only a few unique values, we can quickly scan the frequency counts and confirm that the ~Fandango_Ratingvalue~ column ranges from 2.7 to 4.8 while the ~IMDB_norm~ column ranges from 2 to 4.3. While we can quickly determine the minimum and maximum values, we struggle to answer the following questions about a column:

- What percent of the ratings are contained in the 2.0 to 4.0 range?
  + How does this compare with other sites?
- Which values represent the top 25% of the ratings? The bottom 25%?
  + How does this compare with other sites?

Comparing frequency distributions is also challenging because the ~Fandango_Ratingvalue~ column contains 21 unique values while ~IMDB_norm~ contains 41 unique values. We need a way to compare frequencies across a shared set of values. Because all ratings have been normalized to a range of 0 to 5, we can start by dividing the range of possible values into a series of fixed length intervals, called *bins*. We can then sum the frequencies for the values that fall into each bin. Here's a diagram that makes binning easier to understand:

[[../static/images/histogram_binning.png]]

The distributions for both of these columns are now easier to compare because of the shared x-axis (the bins). We can now plot the bins along with the frequency sums as a bar plot. This type of plot is called a histogram. Let's dive right into creating a histogram in matplotlib.

We can generate a histogram using ~Axes.hist()~. This method has only 1 required parameter, an iterable object containing the values we want a histogram for. By default, matplotlib will:

- calculate the minimum and maximum value from the sequence of values we passed in
- create 10 bins of equal length that span the range from the minimum to the maximum value
- group unique values into the bins
- sum up the associated unique values
- generate a bar for the frequency sum for each bin

The default behavior of Axes.hist() is problematic for the use case of comparing distributions for multiple columns using the same binning strategy. This is because the binning strategy for each column would depend on the minimum and maximum values, instead of a shared binning strategy. We can use the range parameter to specify the range we want matplotlib to use as a tuple:

#+begin_src python
ax.hist(norm_reviews['Fandango_Ratingvalue'], range=(0, 5))
#+end_src

While histograms use bars whose lengths are scaled to the values they're representing, they differ from bar plots in a few ways. Histograms help us visualize continuous values using bins while bar plots help us visualize discrete values. The locations of the bars on the x-axis matter in a histogram but they don't in a simple bar plot. Lastly, bar plots also have gaps between the bars, to emphasize that the values are discrete.

#+BEGIN_SRC ipython :session :file ../static/pyplot/histogram1.png :exports both :results raw drawer
fig, ax = plt.subplots()
ax.hist(norm_reviews["Fandango_Ratingvalue"], range=(0,5))
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/histogram1.png]]
:END:

We can visually examine the proportional area that the bars in the 2.0 to 4.0 range take up and determine that more than 50% of the movies on Fandango fall in this range. We can increase the number of bins from 10 to 20 for improved resolution of the distribution. The length of each bin will be 0.25 (5 / 20) instead of 0.5 (5 / 10). The ~bins~ parameter for ~Axes.hist()~ is the 2nd positional parameter, but can also be specified as a named parameter:

#+begin_src python
# Either of these will work.
ax.hist(norm_reviews['Fandango_Ratingvalue'], 20, range=(0, 5))
ax.hist(norm_reviews['Fandango_Ratingvalue'], bins=20, range=(0, 5))
#+end_src

Let's now generate histograms using 20 bins for all four columns. To ensure that the scales for the y-axis are the same for all histograms, let's set them manually using ~Axes.set_ylim()~.

- For the subplot associated with ax1:
  + Generate a histogram of the values in the ~Fandango_Ratingvalue~ column using 20 bins and a range of 0 to 5.
  + Set the title to Distribution of Fandango Ratings.
- For the subplot associated with ax2:
  + Generate a histogram of the values in the ~RT_user~_norm column using 20 bins and a range of 0 to 5.
  + Set the title to Distribution of Rotten Tomatoes Ratings.
- For the subplot associated with ax3:
  + Generate a histogram of the values in the ~Metacritic_user_nom~ column using 20 bins and a range of 0 to 5.
  + Set the title to Distribution of Metacritic Ratings.
- For the subplot associated with ax4:
  + Generate a histogram of the values in the ~IMDB_norm~ column using 20 bins and a range of 0 to 5.
  + Set the title to Distribution of IMDB Ratings.
- For all subplots:
- Set the y-axis range to 0 to 50 using ~Axes.set_ylim()~.

#+BEGIN_SRC ipython :session :file ../static/pyplot/histogram2.png :exports both :results raw drawer
fig = plt.figure(figsize=(10,10))
ax1 = fig.add_subplot(2,2,1)
ax2 = fig.add_subplot(2,2,2)
ax3 = fig.add_subplot(2,2,3)
ax4 = fig.add_subplot(2,2,4)

ax1.hist(norm_reviews["Fandango_Ratingvalue"], range=(0,5), bins=20)
ax1.set_title("Distribution of Fandango Ratings")
ax1.set_ylim([0,50])

ax2.hist(norm_reviews["RT_user_norm"], range=(0,5), bins=20)
ax2.set_title("Distribution of Rotten Tomatoes Ratings")
ax2.set_ylim([0,50])

ax3.hist(norm_reviews["Metacritic_user_nom"], range=(0,5), bins=20)
ax3.set_title("Distribution of Metacritic Ratings")
ax3.set_ylim([0,50])

ax4.hist(norm_reviews["IMDB_norm"], range=(0,5), bins=20)
ax4.set_title("Distribution of IMDB Ratings")
ax4.set_ylim([0,50])

plt.tight_layout()
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/histogram2.png]]
:END:

**** Boxplot
:PROPERTIES:
:EXPORT_FILE_NAME: boxplot
:EXPORT_DATE: <2017-11-08 Wed>
:END:

A box plot consists of box-and-whisker diagrams, which represents the different quartiles in a visual way. Here's a box plot of the values in the ~RT_user_norm~ column:
[[file:../static/images/boxplot_intro.png]]

The two regions contained within the box in the middle make up the interquartile range, or IQR. The IQR is used to measure dispersion of the values. The ratio of the length of the box to the whiskers around the box helps us understand how values in the distribution are spread out.

We can generate a boxplot using ~Axes.boxplot()~.
#+begin_src python
ax.boxplot(norm_reviews['RT_user_norm'])
#+end_src

Matplotlib will sort the values, calculate the quartiles that divide the values into four equal regions, and generate the box and whisker diagram.
- Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
- Generate a box plot from the values in the RT_user_norm column.
  + Set the y-axis limit to range from 0 to 5.
  + Set the x-axis tick label to Rotten Tomatoes.

#+BEGIN_SRC ipython :session :file ../static/pyplot/histogram3.png :exports both :results raw drawer
fig, ax = plt.subplots()
ax.boxplot(norm_reviews["RT_user_norm"])
ax.set_ylim([0,5])
ax.set_xticklabels(["Rotten Tomatoes"])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/histogram3.png]]
:END:

From the box plot we generated using Rotten Tomatoes ratings, we can conclude that:

- the bottom 25% of user ratings range from around 1 to 2.5
- the top 25% of of user ratings range from around 4 to 4.6

To compare the lower and upper ranges with those for the other columns, we need to generate multiple box-and-whisker diagrams in the same box plot. When selecting multiple columns to pass in to ~Axes.boxplot()~, we need to use the ~values~ accessor to return a multi-dimensional numpy array:

#+begin_src python
num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue', 'Fandango_Stars']
ax.boxplot(norm_reviews[num_cols].values)
#+end_src

- Create a single subplot and assign the returned Figure object to fig and the returned Axes object to ax.
- Generate a box plot containing a box-and-whisker diagram for each column in num_cols.
  + Set the x-axis tick labels to the column names in num_cols and rotate the ticks by 90 degrees.
  + Set the y-axis limit to range from 0 to 5.

#+BEGIN_SRC ipython :session :file ../static/pyplot/histogram4.png :exports both :results raw drawer
num_cols = ['RT_user_norm', 'Metacritic_user_nom', 'IMDB_norm', 'Fandango_Ratingvalue']
subset = norm_reviews[num_cols].values

fig, ax = plt.subplots()

ax.boxplot(subset)
ax.set_xticklabels(num_cols, rotation=90)
ax.set_ylim([0,5])
#+END_SRC

#+RESULTS:
:RESULTS:
[[file:../static/pyplot/histogram4.png]]
:END:

From the boxplot, we can reach the following conclusions:
- user ratings from Rotten Tomatoes and Metacritic span a larger range of values
- user ratings from IMDB and Fandango are both skewed in the positive direction and span a more constrained range of values

* Javascript                                 :@Javascript:
* React                                      :@React:
** Front-End Frameworks
   - JS libraries that handle DOM manipulation
   - Handles navigations (HTML5 push state)
   - State management
** React Intro
   - A view library that uses composable components
[[file:../static/images/react-node.png]]
** Babel
   - Transpiler: converts from one source code version to another
   - JSX => Vanila JS
** JSX with Javascript
   - Write JS inside JSX
   - Use a style attribute in JSX
   - Add a className attribute
** Multiple React Components
*** Render an array of JSX
*** Use a React Component inside of another component
** Create React App
*** Webpack
    - a module bundler for modern JS applications
    - combines different JS files into a bundle.js
    - has a plugin system to run tools like babel
    - Also bundles other assets like css, images etc
    -
** React Props
*** Definition
    - *Immutable* data passed to your components
    - Accessible in component as an object called: this.props
#+begin_src js
class ShowText extents Component {
    render() {
        // Inside the render method, we have access to this.props
        // "this" refers to the ShowText instance
        return <div>{this.props.text}</div>;
    }
}
#+end_src
** Default Props
   Default values for props in a component
#+begin_src js
class FrameList extents Component {
    static defaultProps = {
        types: []
    }
    render(){
        return(
                <ul>
                {this.props.types.mag(val, idx) => (
                        <li key={idx}>{val}</li>
                )}
            </ul>
        )
    }
}
#+end_src
** Props Children
** State
:PROPERTIES:
:EXPORT_FILE_NAME: state
:EXPORT_DATE: <2017-11-09 Thu>
:END:
*** Definition
    - Stateful data
    - Data in application that can change
*** Example
#+begin_src js
class App extends Component {
    constructor(props){
        super(props);
        this.state = { favColor: "red" };
    }

    render(){
        return(
                <div>
                My favorite color: {this.state.favColor};
            </div>          
        )
    }
    
}
#+end_src

*** setState
    - The correct way to change state in your application
    - setState accepts an object with new properties and values for ~this.state~
#+begin_src js
this.setState({});
#+end_src

*** Example
    This is an example of changing state in the application

#+begin_src js
class App extends Component {
    constructor(props) {
        super(props);
        this.state = {
            favColor: "red"
        };

        setTimeout(() => {
            this.setState({favColor: "blue"}, 3000)
        })
    }

    render(){
        return(
                <div>My favorite color: {this.state.favColor}</div>
        )
    }
}
#+end_src

** Pure functions

*** Definition
    - A function with no side effects
    - It does not modify its input
    - It's repeatable (same inputs, same outputs)

Example of a non pure function
#+begin_src js
function doubleValue(arr){
    for(var i = 0; i < arr.length; i++) {
        arr[i] = arr[i] * 2;
    }

    return arr;
}
#+end_src

This function will keep modify the input array.

How to refactor the code and make a pure function? We can use map
#+begin_src js
function doubleVals(arr){
    return arr.map(d => d * 2);
}
#+end_src

Another non pure function where we modify the global variable
#+begin_src js
var person = {id: 53, name: "Tim"};

function addJob(job){
    person.job = job;
}
#+end_src

How to refactor the code to a pure function?
#+begin_src js
var person = {id: 53, name: "Tim"};

function addJob(personObj, job){
    return Object.assign({},
                         personObj,
                         {job});
}
#+end_src

Alternatively we can use the spread operator
#+begin_src js
function addJob(personObj, job){
    return {...personObj, job};
}
#+end_src

All changes to this.state should be pure.

** React Component Architecture

*** How's State Shared?
    - State is always passed from a parent *down* to a child component as a prop
    - State should not be passed to a sibling or a parent

*** Pass state to child components as props

*** Define which components own state

*** Use stateless functional components
* SQL                                        :@SQL:
* R                                          :@R:
* Scala                                      :@Scala:
* Semiotic Data Visualization
